# カルマンフィルタ性能比較シミュレーション (Rust)

## プログラムの概要

このRustプログラムは、非線形な状態を持つ移動体の位置を推定するためのシミュレーションです。様々な種類のカルマンフィルタを実装し、その推定性能を視覚的に比較することを目的としています。

シミュレーションでは、途中で動きのパターンが変わる移動体を想定しています。通常の観測ノイズに加えて、意図的に 外れ値（outlier）を観測データに含めることで、各フィルタの頑健性（ロバスト性）も評価できるようになっています。

-----

## 各フィルタの概要と数学的理論

すべてのカルマンフィルタは、以下の状態空間モデルを基本としています。

- 状態方程式: $`x_k = f(x_{k-1}) + w_{k-1}`$
- 観測方程式: $`z_k = h(x_k) + v_k`$

ここで、各変数は以下の通りです。

- $`x_k`$: 時刻 $`k`$ におけるシステムの状態ベクトル
- $`z_k`$: 時刻 $`k`$ における観測ベクトル
- $`f(\cdot)`$: 状態遷移関数（非線形の場合がある）
- $`h(\cdot)`$: 観測関数（非線形の場合がある）
- $`w_k`$: プロセスノイズ。平均が0、共分散が $`Q`$ の正規分布に従うと仮定される。
- $`v_k`$: 観測ノイズ。平均が0、共分散が $`R`$ の正規分布に従うと仮定される。

フィルタリングは、予測 (Predict) と 更新 (Update) の2つのステップを繰り返すことで実行されます。

### 1\. 基本カルマンフィルタ (KF: Kalman Filter)

線形システムを対象とした最も基本的なフィルタです。非線形モデルを扱う際は、システムを線形とみなして近似計算します。

KFは状態遷移関数 $`f`$ と観測関数 $`h`$ が線形である、つまり行列で表現できると仮定します。

- 状態方程式: $`x_k = F x_{k-1} + w_{k-1}`$
- 観測方程式: $`z_k = H x_k + v_k`$

ここで、$`F`$ は状態遷移行列、$`H`$ は観測行列です。

#### 予測ステップ

- 事前状態推定: $`\hat{x}*{k|k-1} = F \hat{x}*{k-1|k-1}`$
- 事前誤差共分散: $`P_{k|k-1} = F P_{k-1|k-1} F^T + Q`$

#### 更新ステップ

- カルマンゲイン: $`K_k = P_{k|k-1} H^T (H P_{k|k-1} H^T + R)^{-1}`$
- 事後状態推定: $`\hat{x}*{k|k} = \hat{x}*{k|k-1} + K_k (z_k - H \hat{x}_{k|k-1})`$
- 事後誤差共分散: $`P_{k|k} = (I - K_k H) P_{k|k-1}`$

### 2\. 拡張カルマンフィルタ (EKF: Extended Kalman Filter)

非線形関数を、現在の推定値の周りでテイラー展開し、1次の項までで線形近似（局所的な線形化）することで非線形問題に対応します。

EKFでは、非線形関数 $`f, h`$ の代わりに、それらの ヤコビ行列 $`F, H`$ を用いて共分散を伝播させます。

- $`F_k = \frac{\partial f}{\partial x} \bigg|*{\hat{x}*{k-1|k-1}}`$
- $`H_k = \frac{\partial h}{\partial x} \bigg|*{\hat{x}*{k|k-1}}`$

#### 予測ステップ

- 事前状態推定: $`\hat{x}*{k|k-1} = f(\hat{x}*{k-1|k-1})`$  *(← ここは非線形関数を直接使う)*
- 事前誤差共分散: $`P_{k|k-1} = F_k P_{k-1|k-1} F_k^T + Q`$

#### 更新ステップ

- イノベーション（残差）: $`y_k = z_k - h(\hat{x}_{k|k-1})`$ *(← ここも非線形関数を直接使う)*
- イノベーション共分散: $`S_k = H_k P_{k|k-1} H_k^T + R`$
- カルマンゲイン: $`K_k = P_{k|k-1} H_k^T S_k^{-1}`$
- 事後状態推定: $`\hat{x}*{k|k} = \hat{x}*{k|k-1} + K_k y_k`$
- 事後誤差共分散: $`P_{k|k} = (I - K_k H_k) P_{k|k-1}`$

### 3\. アンセンテッドカルマンフィルタ (UKF: Unscented Kalman Filter)

アンセンテッド変換 (Unscented Transform) を用いて、状態の確率分布を表現する少数の点（シグマポイント）を非線形関数で直接変換します。ヤコビ行列の計算が不要で、EKFより高い精度が期待できます。

UKFは、$`2n+1`$個の シグマポイント（$n$は状態ベクトルの次元）とその重みを計算し、非線形変換後の平均と共分散を再構成します。

1. シグマポイントの生成:
    状態の平均 $`\hat{x}`$ と共分散 $`P`$ から、$`2n+1`$個のシグマポイント $`\mathcal{X}_i`$ と重み $`W_i`$ を計算します。

    $`
    \begin{cases}
    \mathcal{X}_0 = \hat{x} \\
    \mathcal{X}_i = \hat{x} + (\sqrt{(n+\lambda)P})\_i & i=1, \dots, n \\
    \mathcal{X}*i = \hat{x} - (\sqrt{(n+\lambda)P})*{i-n} & i=n+1, \dots, 2n
    \end{cases}
    `$

    ここで $`\lambda`$ はスケーリングパラメータ、$`(\sqrt{\cdot})_i`$ は行列平方根の $`i`$ 番目の列ベクトルです。

2. 予測ステップ:

      - 各シグマポイントを状態遷移関数で変換します: $`\mathcal{X}^**{i, k|k-1} = f(\mathcal{X}*{i, k-1|k-1})`$
      - 事前状態推定値と共分散を、重み付き和で再構成します。

      $`
      \hat{x}*{k|k-1} = \sum*{i=0}^{2n} W_i^{(m)} \mathcal{X}^**{i, k|k-1}
      `$

      $`
      P*{k|k-1} = \sum_{i=0}^{2n} W_i^{(c)} (\mathcal{X}^**{i, k|k-1} - \hat{x}*{k|k-1})(\mathcal{X}^**{i, k|k-1} - \hat{x}*{k|k-1})^T + Q
      `$

3. 更新ステップ:

      - 予測された状態から再度シグマポイントを生成し、観測関数 $`h`$ で変換します: $`\mathcal{Z}*i = h(\mathcal{X}*{i, k|k-1})`$
      - 予測観測値 $`\hat{z}*k`$、イノベーション共分散 $`S_k`$、相互共分散 $`P*{xz}`$ を計算します。
      - カルマンゲイン $`K_k = P_{xz}S_k^{-1}`$ を計算し、状態と共分散を更新します（式はKFと同様）。

### 4\. キューバチャーカルマンフィルタ (CKF: Cubature Kalman Filter)

UKFと似たサンプリングベースの手法ですが、球面ラジアル則に基づく $`2n`$ 個の キューバチャーポイントを用います。全てのポイントの重みが等しいため、実装が単純で数値的に安定しています。

CKFは、ガウス分布に対する積分を数値的に近似するための3次の球面ラジアル則を利用します。

1. キューバチャーポイントの生成:
    共分散行列 $`P`$ をコレスキー分解 $`P = S S^T`$ します。$`2n`$ 個のキューバチャーポイント $`\mathcal{X}_i`$ は以下のように計算されます。

    $`
    \mathcal{X}_i = \hat{x} + \sqrt{n} S_i \quad (i=1, \dots, 2n)
    `$

    ここで $`S_i`$ は $`S`$ の $`i`$ 番目の列ベクトル（$`i\>n`$ の場合は $`-S_{i-n}`$）です。重みは全て $`W_i = \frac{1}{2n}`$ となります。

2. 予測・更新ステップ:
    予測と更新のプロセスはUKFとほぼ同じです。各ポイントを非線形関数で変換し、その平均と共分散を計算して、予測値やカルマンゲインを求めます。重みが全て等しいため、計算式はUKFよりシンプルになります。

      - 予測: $`\hat{x}*{k|k-1} = \frac{1}{2n}\sum*{i=1}^{2n} f(\mathcal{X}_i)`$
      - 更新: $`\hat{z}*k = \frac{1}{2n}\sum*{i=1}^{2n} h(\mathcal{X}_i)`$

### 5\. ロバストキューバチャーカルマンフィルタ (RCKF: Robust CKF)

CKFをベースに、外れ値に対する耐性を向上させたフィルタです。イノベーション（観測残差）の マハラノビス距離 を計算し、それが大きい場合に観測ノイズの共分散 $R$ を一時的に大きくして、外れ値の影響を低減させます。

更新ステップにおいて、以下の処理が追加されます。

1. イノベーション $`y_k = z_k - \hat{z}_{k|k-1}`$ とイノベーション共分散 $S_k$ をCKFと同様に計算します。
2. イノベーションのマハラノビス距離の2乗を計算します。

    $`
    d^2 = y_k^T S_k^{-1} y_k
    `$

3. $`d^2`$ が事前に定めたしきい値 $`\delta`$（カイ二乗分布から導かれる）より大きいか判定します。
      - もし $`d^2 > \delta`$ ならば (外れ値と判断):
        観測ノイズ共分散を一時的に大きくします ($`R_{eff} = \lambda R`$, ただし $`\lambda \gg 1`$)。これにより、カルマンゲインが小さくなり、異常な観測値が状態推定に与える影響が抑制されます。
      - そうでなければ (正常な観測値と判断):
        通常のCKFと同じ更新を行います ($`R_{eff} = R`$)。

### 6\. 対話型多重モデルフィルタ (IMM-UKF: Interacting Multiple Model Filter)

システムの振る舞いが単一のモデルでは表現できない場合に有効な手法です。複数の運動モデル（この実装ではUKF）を並行して実行し、それぞれのモデルが現在の状況にどれだけ適合しているかを確率的に計算しながら、結果を統合します。

IMMアルゴリズムは4つのステップからなるサイクルを繰り返します。

1. Interaction (混合):
    時刻 $`k-1`$ におけるモデル $i$ の推定結果 ($`\hat{x}*{k-1|k-1}^{(i)}`$, $`P*{k-1|k-1}^{(i)}`$) とモデル確率 $`\mu_{k-1}^{(i)}`$ を、モデル遷移行列 $`T_{ji}`$ を用いて混合し、時刻 $`k`$ のフィルタリングの初期値となる混合推定値 $`\hat{x}*{0,k-1|k-1}^{(j)}`$ と混合共分散 $`P*{0,k-1|k-1}^{(j)}`$ を各モデル $`j`$ について計算します。

2. Filtering:
    各モデル $`j`$ で、混合された初期値を用いて、それぞれに割り当てられたフィルタ（ここではUKF）を実行します（予測と更新）。この過程で、各モデルの観測値に対する 尤度 $`\Lambda_k^{(j)}`$ を計算します。

3. Model Probability Update (モデル確率の更新):
    ベイズの定理に基づき、各モデルの尤度 $`\Lambda_k^{(j)}`$ と遷移前の確率を用いて、モデル確率 $`\mu_k^{(j)}`$ を更新します。

   $` 
    \mu_k^{(j)} = \frac{\Lambda_k^{(j)} \sum_{i=1}^M T_{ij} \mu_{k-1}^{(i)}}{\sum_{l=1}^M \Lambda_k^{(l)} \sum_{i=1}^M T_{il} \mu_{k-1}^{(i)}}
   `$

4. Combination (結合):
    更新されたモデル確率 $`\mu_k^{(j)}`$ を重みとして、各モデルの推定結果 ($`\hat{x}*{k|k}^{(j)}`$, $`P*{k|k}^{(j)}`$) を結合し、最終的な状態推定値 $`\hat{x}*{k|k}`$ と誤差共分散 $`P*{k|k}`$ を算出します。

    $`
    \hat{x}*{k|k} = \sum*{j=1}^M \mu_k^{(j)} \hat{x}_{k|k}^{(j)}
    `$

    これにより、システムの挙動が変化しても、最も適合するモデルの重みが大きくなり、ロバストな推定が可能になります。

-----

## 実行方法

1. Rust環境のセットアップ:
    もしRustがインストールされていない場合は、[公式サイト](https://www.rust-lang.org/tools/install)の指示に従ってインストールしてください。

2. リポジトリのクローンと実行:

    ```bash
    # プログラムのビルドと実行
    cargo run --release
    ```

3. 結果の確認:
    実行が完了すると、プロジェクトのルートディレクトリに `rust_plotters_comparison.svg` という名前の画像ファイルが生成されます。このファイルを開くと、各フィルタの推定結果をプロットしたグラフを確認できます。

## 🔗 依存ライブラリ

このプロジェクトは以下のライブラリに依存しています。

- [`nalgebra`](https://www.google.com/search?q=%5Bhttps://nalgebra.org/%5D\(https://nalgebra.org/\)): 線形代数ライブラリ
- [`rand`](https://www.google.com/search?q=%5Bhttps://crates.io/crates/rand%5D\(https://crates.io/crates/rand\)): 乱数生成ライブラリ
- [`plotters`](https://www.google.com/search?q=%5Bhttps://crates.io/crates/plotters%5D\(https://crates.io/crates/plotters\)): グラフ描画ライブラリ
